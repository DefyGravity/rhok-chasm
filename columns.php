<?php

include_once "profile.php";
/*
// Constant for Height
define("H", "height");

// Constant for Length
define("L", "length");

// Constant for Theta
define("THETA", "angle");

// Constant for X coordinate
define("X", 0);

// Constant for Y coordinate
define("Y", 1);
*/

// Convert degrees to radians
function degreesToRadians( $degrees ) {
	return $degrees * pi() / 180.0;
}

// Convert radians to degrees
function radiansToDegrees( $radians ) {
	return $radians * 180.0 / pi();
}

// Get the height value given length and theta (in degrees)
function getH( $l, $theta ) {
	return $l * sin( degreesToRadians( $theta ) );
}

// Get the length value given height and theta(in degrees)
function getL( $h, $theta ) {
	return $h / sin( degreesToRadians( $theta ) );
}

// Get the theta value (in degrees) given the height and length
function getTheta( $h, $l ) {
	return radiansToDegrees( asin( $h / $l ) );
}

// Given a point, height, length and theta (in degrees), calculates the next X,Y coordinate
function getNextPoint( $x, $y, $height, $length, $theta ) {
	// given an [x, y] coordinate, length, and theta angle, computes the next [x, y] coordiate
	$x_coord = round( $x + $length * cos( degreesToRadians( $theta ) ) );
	$y_coord = round( $y - $height );
	return array( $x_coord, $y_coord );
}

// Given data array, computes total height
function getTotalHeight($data) {
	$totalHeight = 0;
	
	for ($i=0; $i < count($data); $i++) {
		$totalHeight += $data[$i][Chasm_Profile_Parser::H];
	}
	
	return $totalHeight;
}

// Given data array, generates array of XY coordinates
function generateXYPoints( $data ) {
	
	$originHeight = getTotalHeight( $data );
		
	// one more point than there are measurements
	$xyPoints = array();
	
	array_push($xyPoints, array(0, $originHeight));

	
	for ($i=0; $i<count($data); $i++) {
		array_push($xyPoints, getNextPoint( $xyPoints[$i][Chasm_Profile_Parser::X], $xyPoints[$i][Chasm_Profile_Parser::Y], $data[$i][Chasm_Profile_Parser::H], $data[$i][Chasm_Profile_Parser::L], $data[$i][Chasm_Profile_Parser::THETA] ));
	}

	return $xyPoints;
}

function generateLayerXYPoints( $data, $layer ) {
    // TODO!!
}

/********* BEGIN DATA PROCESSING FUNCTIONS **************/

define("INVALID_DATA", 9);
define("SOIL_TYPE", "soiltype");

define("BR", "\n");

/*
Given cells generated by generateCells(...), prints out the geometry file format in proper format
*/
function generateFile( $cells, $water_columns ) {
	
	echo "<pre>";
	echo count($cells) . BR;
	
	for ( $row=0; $row<count($cells); $row++ ) {
		// clear 9's
		while ( $cells[$row][0] == 9 ) {
			array_shift($cells[$row]);
		}
		
		$num_cells = count( $cells[$row] );
		$num_water = $water_columns[$row];
		$column_width = 1;
		$column_breadth = 1;
		$initial_surface_section = -0.5;
		
		echo $num_cells . " " . $num_water . " " . $column_width . " " . $column_breadth . " " . $initial_surface_section . BR;

		$text = "1 " . $cells[$row][0];
		for ( $col=1; $col<count($cells[$row]); $col++ ) {
			$text = $text . " 1 " . $cells[$row][$col];
		}
		echo $text . BR;
	}
	
	// EOF marker
	echo "0 0";
	echo "</pre>";
}

function generateWaterColumns( $width, $water ) {

	$results = array();
	
	for ( $x=0; $x < $width; $x++ ) {
		$line_seg_idx = findSegment( $x, $water );
		
		$x1 = $water[$line_seg_idx-1][Chasm_Profile_Parser::X];
		$y1 = $water[$line_seg_idx-1][Chasm_Profile_Parser::Y];
				
		$x2 = $water[$line_seg_idx][Chasm_Profile_Parser::X];
		$y2 = $water[$line_seg_idx][Chasm_Profile_Parser::Y];
		
		// calculate slope
		$slope = ( $y2 - $y1 ) / ( $x2 - $x1 );
	
		// calculate y value at the x-coordinate
		$y = round( $slope * ( $x - $x1 ) + $y1 );
	
		array_push($results, $y);
	}
	
	return $results;
}

/*
Given the profile/line segements, generates the cell data matrix

Assumes that the line segments are in right order (i.e. profile > soil1 > soil2 > soil3 > soil4

Expected soil data structure:

$soil => 	{ 	
			{x1, y1},
			{x2,y2},
			...
			"soiltype" => (0|1|2|3)
		}
*/
function generateCells( $profile, $soil1, $soil2, $soil3, $soil4 ) {

	$height = $profile[0][Chasm_Profile_Parser::Y];
	$width = $profile[count($profile)-1][Chasm_Profile_Parser::X];
	
	$columns = array();
	
	$x = 0.5;
	while ( $x < $width ) {
		array_push($columns, generateColumn( $x, $height, $profile, $soil1, $soil2, $soil3, $soil4 ) );
		$x += 1.0;
	}
	
	$data = array();

	for ($col=0; $col<$height; $col++) {
		$temp = array();
		for ($row=0; $row<$width; $row++) {		
			array_push($temp, $columns[$row][$col]);
		}
		
		array_push($data, $temp);
	}
		
	return $columns;
}

/*
Given the max height, the x coord of the column, and the profile/soil line segements, generates the column data

Assumes that the line segments are in right order (i.e. profile > soil1 > soil2 > soil3 > soil4

Expected soil data structure:

$soil => 	{ 	
			{x1, y1},
			{x2,y2},
			...
			"soiltype" => (0|1|2|3)
		}
*/
function generateColumn( $x, $height, $profile, $soil1, $soil2, $soil3, $soil4 ) {
	
	$y=$height - 0.5;
	
	$column = array();
	
	while ($y > 0) {
		array_push($column, getCellValue( $x, $y, $profile, $soil1, $soil2, $soil3, $soil4 ));		
		$y -= 1.0;
	}
	
	return $column;
}

/* Given the (x,y) coordinate, the profile lines, soil lines, calculates the correct value.

Assumes that the line segments are in right order (i.e. profile > soil1 > soil2 > soil3 > soil4

Expected soil data structure:

$soil => 	{ 	
			{x1, y1},
			{x2,y2},
			...
			"soiltype" => (0|1|2|3)
		}
*/
function getCellValue( $x_coord, $y_coord, $profile, $soil1, $soil2, $soil3, $soil4 ) {
	$line_seg_idx = findSegment( $x_coord, $profile );
	
	if ( isAboveLine( $x_coord, $y_coord, 
			$profile[$line_seg_idx-1][Chasm_Profile_Parser::X], $profile[$line_seg_idx-1][Chasm_Profile_Parser::Y], 
			$profile[$line_seg_idx][Chasm_Profile_Parser::X], $profile[$line_seg_idx][Chasm_Profile_Parser::Y] ) ) {
			
		return INVALID_DATA;
	}
	
	$line_seg_idx = findSegment( $x_coord, $soil1 );
	if ( isAboveLine( $x_coord, $y_coord, 
			$soil1[$line_seg_idx-1][Chasm_Profile_Parser::X], $soil1[$line_seg_idx-1][Chasm_Profile_Parser::Y], 
			$soil1[$line_seg_idx][Chasm_Profile_Parser::X], $soil1[$line_seg_idx][Chasm_Profile_Parser::Y] ) ) {
			
		return $soil1[SOIL_TYPE];// should just return 1
	}
	
	$line_seg_idx = findSegment( $x_coord, $soil2 );
	if ( isAboveLine( $x_coord, $y_coord, 
			$soil2[$line_seg_idx-1][Chasm_Profile_Parser::X], $soil2[$line_seg_idx-1][Chasm_Profile_Parser::Y], 
			$soil2[$line_seg_idx][Chasm_Profile_Parser::X], $soil2[$line_seg_idx][Chasm_Profile_Parser::Y] ) ) {
			
		return $soil2[SOIL_TYPE];// should just return 2
	}
	
	$line_seg_idx = findSegment( $x_coord, $soil3 );
	if ( isAboveLine( $x_coord, $y_coord, 
			$soil3[$line_seg_idx-1][Chasm_Profile_Parser::X], $soil3[$line_seg_idx-1][Chasm_Profile_Parser::Y], 
			$soil3[$line_seg_idx][Chasm_Profile_Parser::X], $soil3[$line_seg_idx][Chasm_Profile_Parser::Y] ) ) {
			
		return $soil3[SOIL_TYPE];// should just return 3
	}
	
	$line_seg_idx = findSegment( $x_coord, $soil4 );
	if ( isAboveLine( $x_coord, $y_coord, 
			$soil4[$line_seg_idx-1][Chasm_Profile_Parser::X], $soil4[$line_seg_idx-1][Chasm_Profile_Parser::Y], 
			$soil4[$line_seg_idx][Chasm_Profile_Parser::X], $soil4[$line_seg_idx][Chasm_Profile_Parser::Y] ) ) {
			
		return $soil4[SOIL_TYPE];// should just return 4
	}
	
	return INVALID_DATA;
}

/*
Given an (x,y) coordinate, and the measured (x1, y1) (x2, y2) pairs from a line segment, compute
whether the given coordinate is above the line

Returns true if the y value is strictly above the line; false otherwise
*/
function isAboveLine( $x_coord, $y_coord, $x1, $y1, $x2, $y2 ) {

	// calculate slope
	$slope = ( $y2 - $y1 ) / ( $x2 - $x1 );
	
	// calculate y value at the x-coordinate
	$y = $slope * ( $x_coord - $x1 ) + $y1;
	
	return ( $y_coord > $y );
}

/*
Given an x coordinate and a contiguous set of ordered line segments, finds the
pair of line segments between which the x coordinate lies.
*/
function findSegment( $x_coord, $line_segments ) {
    
	for ($i=0; $i < count($line_segments); $i++) {
		if ( $line_segments[$i][Chasm_Profile_Parser::X] > $x_coord ) {
			return $i;
		}		
	}
}
?>